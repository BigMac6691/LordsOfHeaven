// Generated by ChatGPT
class ColorUtils 
{
    static rgbToLab(r, g, bValue) 
    {
        function f(t) 
        {
            return t > 0.008856 ? Math.cbrt(t) : (7.787 * t) + (16 / 116);
        }

        // Convert RGB to XYZ
        let R = r / 255, G = g / 255, B = bValue / 255;
        R = R > 0.04045 ? ((R + 0.055) / 1.055) ** 2.4 : R / 12.92;
        G = G > 0.04045 ? ((G + 0.055) / 1.055) ** 2.4 : G / 12.92;
        B = B > 0.04045 ? ((B + 0.055) / 1.055) ** 2.4 : B / 12.92;

        let X = (R * 0.4124564 + G * 0.3575761 + B * 0.1804375) / 0.95047;
        let Y = (R * 0.2126729 + G * 0.7151522 + B * 0.0721750) / 1.00000;
        let Z = (R * 0.0193339 + G * 0.1191920 + B * 0.9503041) / 1.08883;

        let L = (116 * f(Y)) - 16;
        let a = 500 * (f(X) - f(Y));
        let b = 200 * (f(Y) - f(Z));

        return { L, a, b };
    }

    static deltaE(color1, color2) 
    {
        return Math.sqrt(
            (color1.L - color2.L) ** 2 +
            (color1.a - color2.a) ** 2 +
            (color1.b - color2.b) ** 2
        );
    }

    static rgbToHsv(r, g, b) 
    {
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let d = max - min, h = 0;

        if (d === 0) h = 0;
        else if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;

        h = Math.round(h * 60);

        return h;
    }

    static hexToRgb(hex) 
    {
        let bigint = parseInt(hex.slice(1), 16);

        return {r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255};
    }

    static isColorDistinct(newColor, existingColors, threshold = 20, useLab = true) 
    {
        if (useLab) 
        {
            let newLab = ColorUtils.rgbToLab(newColor.r, newColor.g, newColor.b);
            
            return existingColors.every(existing => ColorUtils.deltaE(ColorUtils.rgbToLab(existing.r, existing.g, existing.b), newLab) > threshold);
        } 
        else 
        {
            let newHue = ColorUtils.rgbToHsv(newColor.r, newColor.g, newColor.b);
            
            return existingColors.every(existing => Math.abs(ColorUtils.rgbToHsv(existing.r, existing.g, existing.b) - newHue) > threshold);
        }
    }

    static isHexColorDistinct(newHexColor, existingHexColors, threshold = 20, useLab = true) 
    {
        const newColor = ColorUtils.hexToRgb(newHexColor);
        const existingColors = existingHexColors.map(ColorUtils.hexToRgb);

        return ColorUtils.isColorDistinct(newColor, existingColors, threshold, useLab);
    }

    static isHexColorDifferent(newColor, oldColor, threshold = 20, useLab = true)
    {
        return ColorUtils.isHexColorDistinct(newColor, [oldColor], threshold, useLab);
    }
}

export {ColorUtils};